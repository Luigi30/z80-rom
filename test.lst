              	; --------------------------------------
              	; zasm: assemble "test.asm"
              	; date: 2020-02-06 02:37:38
              	; --------------------------------------


              	#target rom
              	
              	#include "bios.inc"
0000:         	B_CONOUT        = 0
0001:         	B_STROUT        = 1
0002:         	B_CONIN         = 2
0003:         	B_CONSTAT       = 3
0004:         	B_STRIN         = 4
              	
              	DoBIOS	.macro
              			rst	$20
              			.endm
              	
              		;; SIO equates
0081:         	SIOA_D	.EQU $81
0080:         	SIOA_C	.EQU $80
0083:         	SIOB_D	.EQU $83
0082:         	SIOB_C	.EQU $82
              		
8000:         	#data 	DATA,0x8000,0x8000
              	
0000:         	#code	_BOOT,0h,200h		; Reset vector, RST vectors, NMI vectors
              	
              		;;  see rc2014init.asm
              		
0000: F3      	RST00:	di			; interrupts off
0001: C30002  			jp	Start
0004: 00      			nop
0005: 00      			nop
0006: 00      			nop
0007: 00      			nop			
              	
0008: C32602  	RST08:	jp	rc2014_sio_TX	; 0x08
000B: 00      			nop
000C: 00      			nop
000D: 00      			nop
000E: 00      			nop
000F: 00      			nop
              	
0010: C30B02  	RST10:	jp	rc2014_getc	; 0x10
0013: 00      			nop
0014: 00      			nop
0015: 00      			nop
0016: 00      			nop
0017: 00      			nop
              	
0018: C31C02  	RST18:	jp	rc2014_pollc	; 0x18
001B: 00      			nop
001C: 00      			nop
001D: 00      			nop
001E: 00      			nop
001F: 00      			nop
              	
0020: C36002  	RST20:	jp	B_Dispatch	; 0x20
0023: 00      			nop
0024: 00      			nop
0025: 00      			nop
0026: 00      			nop
0027: 00      			nop
              	
0028: C9      	RST28:	ret
0029: 00      			nop
002A: 00      			nop
002B: 00      			nop
002C: 00      			nop
002D: 00      			nop
              		
002E: C9      	RST30:	ret
002F: 00      			nop
0030: 00      			nop
0031: 00      			nop
0032: 00      			nop
0033: 00      			nop
              	
0034: ED4D    	RST38:	reti
0036: 00      			nop
0037: 00      			nop
0038: 00      			nop
0039: 00      			nop
003A: 00      			nop
              		
              	;;; ;;;;;;;;;;;;;;;;
              	
0200:         	#code	_CODE,0x200,0x1E00	; 8K page total
              	
0200:         	Start:
0200: 21F9FF  		ld		hl,$FFF9	; initialize stack
0203: F9      		ld		sp,hl
              	
0204: F3      		di
0205: CD3102  		call	rc2014_sio_init
0208: C37603  		jp		Greet
              	
              	#include 	"rc2014.asm"
              	;;; rc2014_getc
              	;;; Wait for the UART to receive a character.
              	;;; Return the character in HL.
020B:         	rc2014_getc:
020B: F5      	        push 	af
020C: DB80    	waitch:	in 		a,(SIOA_C)
020E: CB47    	        bit 	0,a
0210: 28FA    	        jr 		z,waitch
0212: DB81    	        in 		a,(SIOA_D)
0214: 2600    	        ld 		h,0
0216: 6F      	        ld 		l,a
0217: F1      	        pop 	af
0218: C9      	        ret
              	
              	;;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
              	;;; rc2014_putc
              	;;; Output the byte in L to the SIO.
              	;;;
0219:         	rc2014_putc:
0219: 7D      		ld	a,l
021A: CF      		rst	$08
021B: C9      		ret
              	
              	;;; rc2014_pollc
              	;;; Poll the UART receive buffer.
              	;;; L <- 1 if data available
              	;;; L <- 0 if no data available
021C:         	rc2014_pollc:
021C: 2E00    		ld	l,0
021E: DB80    		in	a,(SIOA_C)
0220: CB47    		bit	0,a
0222: C8      		ret	z
0223: 2E01    		ld	l,1
0225: C9      		ret
              	
              	;;; ;;;;;;;;;;;;;
0226:         	rc2014_sio_TX:
              	#local
0226: F5      			push af
0227: DB80    	txbusy: in a,($80)          ; read serial status
0229: CB57    	        bit 2,a             ; check status bit 2
022B: 28FA    	        jr z, txbusy        ; loop if zero (serial is busy)
022D: F1      	        pop af
022E: D381    	        out ($81), a        ; transmit the character
0230: C9      	        ret
              	#endlocal
              	
              	;;; ;;;;;;;;;;;;;
0231:         	rc2014_sio_init:
              	;;; Set up the SIO channel A for UART transmit/receive.
0231: 3E30    		ld	a,00110000b	; WR0: error reset, select WR0
0233: D380    		out	(SIOA_C),a
0235: 3E18    		ld	a,018h		; WR0: reset
0237: D380    		out	(SIOA_C),a
              	
0239: 3E04    		ld	a,04h		; WR0: select WR4
023B: D380    		out	(SIOA_C),a
023D: 3EC4    		ld	a,11000100b	; WR4: CLK/64, 1 stop, N parity (at 2.4MHz, 38400bps)
023F: D380    		out	(SIOA_C),a
              	
0241: 3E05    		ld	a,05h		; WR0: select WR5
0243: D380    		out	(SIOA_C),a
0245: 3EE8    		ld	a,11101000b	; DTR, TX 8bit, no BRK, TX on, no RTS
0247: D380    		out	(SIOA_C),a
              	
0249: 3E01    		ld	a,01h		; WR0: select WR1
024B: D382    		out	(SIOB_C),A
024D: 3E04    		ld	a,00000100b	; No CH B interrupt
              	
024F: 3E01    		ld	a,01h		; WR0: Select WR1
0251: D380    		out	(SIOA_C),A	
0253: 3E00    		ld	a,00h		; WR1: All interrupts off
0255: D380    		out	(SIOA_C),A
              	
              		;; Enable SIO RX on channel A.
0257: 3E03    		ld	a,03h
0259: D380    		out	(SIOA_C),a
025B: 3EC1    		ld	a,0C1h		; RX 8bit, RX on, auto enable off
025D: D380    		out	(SIOA_C),a
              	
025F: C9      		ret
              	
              	;;; ;;;;;;;;;;;;;;;;;
              	;;; BIOS functions
              	;;;
              	;;; API:
              	;;;		All BIOS functions are prefixed with B_
              	;;; 	Input is DE
              	;;;		Output bytes are in A
              	;;;		Output words are in HL (todo: ?)
              	;;;
              	;;;		Do not assume any registers are preserved.
0260:         	B_Dispatch:
              		;; Dispatch to the function number C.
0260: D5      		push	de
0261: F5      		push	af
0262: 210003  		ld		hl,BIOS_FnTable	; grab the jump table address
0265: 1600    		ld		d,0		; clear D
              		
0267: CB21    		sla		c		; shift C to produce a table offset
0269: 59      		ld		e,c		; E <- C
026A: 19      		add		hl,de	; Apply the offset.
026B: 5E23562B		ld		de,(hl)	; Get the destination address.
026F: 626B    		ld		hl,de	; Move it into HL so we can jump to it.
              	
0271: F1      		pop		af		; Restore AF and DE.
0272: D1      		pop		de
0273: E9      		jp		(hl)	; Jump to the BIOS function, which RETs back to where we started.
0274: C9      		ret				; Unnecessary unless something breaks
              		
              	;;
0275:         	B_Conout:
              		;; CONsole OUTput.
              		;; 
              		;; Input:
              		;; E - character
0275: 7B      		ld		a,e
0276: CD2602  		call	rc2014_sio_TX
0279: C9      		ret
              	
              	;;
              	#local
027A:         	B_Strout::
              		;; STRing OUTput.
              		;; Input:
              		;; DE - string address
              		;;
              		;; Perform B_Conout until a 0 is found in the string.
027A:         	1$:	
027A: 1A      		ld		a,(de)
027B: FE00    		cp		#0
027D: 2809    		jr		z,2$
027F: D5      		push	de
0280: 5F      		ld		e,a
0281: CD7502  		call	B_Conout
0284: D1      		pop		de
0285: 13      		inc		de
0286: 18F2    		jr		1$
              	
0288:         	2$:
0288: C9      		ret	
              	#endlocal	
              	;;
              	
0289:         	B_Conin:
              		;; CONsole INput.
              		;;
              		;; Blocks until a character is available on the console.
              		;; Output:
              		;; A = character received
0289: CD0B02  		call	rc2014_getc	; returns char in L
028C: 7D      		ld		a,l			; copy it to A and return
028D: C9      		ret
              		;;
              	
028E:         	B_Constat:
              		;; CONsole STATus.
              		;;
              		;; Output:
              		;; A  = 0 if no characters are waiting to be read
              		;; A != 0 if character is waiting
028E: CD1C02  		call	rc2014_pollc
0291: 7D      		ld		a,l
0292: C9      		ret
              	
              	#local
0293:         	B_Strin::
              		;; Read string into buffer.
              		;; Buffer structure is as follows:
              		;;	db buffer_size		- how many characters are allowed
              		;;	db input_length 	- populated after input is complete
              		;;	byte[buffer_size] 	- the input string
              		;;
              		;; Buffer address is placed in DE.
0293: FD62FD6B		ld		iy,de	; Copy buffer base address to IY
0297: FD23    		inc		iy
0299: FD23    		inc		iy		; advance 2 bytes to start of the string buffer
              	
029B: DD210000		ld		ix,0	; clear input length
              	
029F:         	begin:
029F: D7      		rst		$10		; Get an input character.
              	
              		; Check for Ctrl+H
02A0: 7D      		ld		a,l
02A1: FE08    		cp		$08
02A3: 2805    		jr		z,handlebs
              	
02A5:         	check2:
              		; Check for 0x7F (some terminals use this instead)
02A5: 7D      		ld		a,l
02A6: FE7F    		cp		$7F	
02A8: 2027    		jr		nz,charout	; Any other character bypasses
              	
02AA:         	handlebs:
              		;; Handle the backspace.
02AA: DD7D    		ld		a,ixl	; is the input length already 0? if so, ignore and go back to waiting for input
02AC: FE00    		cp		0
02AE: 28EF    		jr		z,begin
              	
              		; Reset the write pointer and length.
02B0: FD2B    		dec		iy
02B2: DD2B    		dec		ix
              	
02B4: D5      		push	de
02B5: E5      		push	hl
02B6: DDE5    		push	ix
02B8: FDE5    		push	iy
02BA: 1E08    		ld		e,$08
02BC: 0E00    		ld		c,B_CONOUT
              		DoBIOS		; console BS
02BE: E7      			rst	$20
02BF: 1E20    		ld		e,$20
02C1: 0E00    		ld		c,B_CONOUT
              		DoBIOS		; console SPC
02C3: E7      			rst	$20
02C4: 1E08    		ld		e,$08
02C6: 0E00    		ld		c,B_CONOUT
              		DoBIOS		; console BS
02C8: E7      			rst	$20
02C9: FDE1    		pop		iy
02CB: DDE1    		pop		ix
02CD: E1      		pop		hl
02CE: D1      		pop		de
02CF: 18CE    		jr		begin	; And we're done.
              	
02D1:         	charout:
              		; write character to buffer
02D1: FD7500  		ld		(iy),l	; copy the character to the input buffer
02D4: FD23    		inc		iy		; advance buffer
02D6: DD23    		inc		ix		; length++
              	
              		; TODO: Length == buffer size? If so, don't allow more characters.
              	
02D8:         	write:	
              		; write character to console
02D8: D5      		push	de
02D9: E5      		push	hl
02DA: DDE5    		push	ix
02DC: FDE5    		push	iy
02DE: 5D      		ld		e,l
02DF: 0E00    		ld		c,B_CONOUT
              		DoBIOS
02E1: E7      			rst	$20
02E2: FDE1    		pop		iy
02E4: DDE1    		pop		ix
02E6: E1      		pop		hl
02E7: D1      		pop		de
              	
              		; Is the character 0x0D?
02E8: 7D      		ld		a,l
02E9: FE0D    		cp		$0D	; LF
02EB: 20B2    		jr		nz,begin		; loop if no
              	
              		; add a null
02ED: 2E00    		ld		l,0
02EF: FD7500  		ld		(iy),l	; copy the character to the input buffer
02F2: FD23    		inc		iy		; advance buffer
02F4: DD23    		inc		ix		; length++
              	
              		; Write the length to the buffer struct
02F6: DD7D    		ld		a,ixl
02F8: FD62FD6B		ld		iy,de
02FC: FD7701  		ld		(iy+1),a
              	
02FF: C9      		ret
              	#endlocal
              	
0300:         	BIOS_FnTable:
0300: 7502    		.dw B_Conout		; C = 0
0302: 7A02    		.dw	B_Strout		; C = 1
0304: 8902    		.dw	B_Conin			; C = 2
0306: 8E02    		.dw	B_Constat		; C = 3
0308: 9302    		.dw	B_Strin			; C = 4
              	#include	"strings.asm"
030A:         	strPrompt:
030A: 3E00    		.asciz	">"
030C:         	strCRLF:
030C: 0D0A00  		.ascii	13,10,0
              	
030F:         	HelloWorld:
030F: 50726F63		.ascii	"Procyon/80 ROM Monitor - RC2014 SIO/2 64K",13,10,0
0313: 796F6E2F	
0317: 38302052	
031B: 4F4D204D	
031F: 6F6E6974	
0323: 6F72202D	
0327: 20524332	
032B: 30313420	
032F: 53494F2F	
0333: 32203634	
0337: 4B0D0A00	
              	
033B:         	strYouEntered:
033B: 596F7520		.asciz	"You entered: "
033F: 656E7465	
0343: 7265643A	
0347: 2000    	
              	
0349:         	strDbgCmd:
0349: 436F6D6D	    .asciz  "Command: "
034D: 616E643A	
0351: 2000    	
              	
0353:         	strDbgArg:
0353: 20202020	    .asciz  "    Arg: "
0357: 4172673A	
035B: 2000    	
              	
035D:         	strCmdUnknown:
035D: 2A2A2A20	    .asciz  "*** Unrecognized command"
0361: 556E7265	
0365: 636F676E	
0369: 697A6564	
036D: 20636F6D	
0371: 6D616E64	
0375: 00      	
              		
0376:         	Greet:
0376: 110F03  		ld		de,HelloWorld
0379: 0E01    		ld		c,B_STROUT
037B: E7      		rst		$20
              	
037C:         	GetInputString:
              		; reset offset
037C: 110A03  		ld		de,strPrompt
037F: 0E01    		ld		c,B_STROUT
              		DoBIOS
0381: E7      			rst	$20
              	
0382: CD0606  		call	ClearInputBuffer
0385: 114880  		ld		de,buffer_base
0388: 0E04    		ld		c,B_STRIN
              		DoBIOS
038A: E7      			rst	$20
038B: 110C03  		ld		de,strCRLF
038E: 0E01    		ld		c,B_STROUT
              		DoBIOS
0390: E7      			rst	$20
              	
              		; Take the first two bytes of buffer_Input and put them in the command register.
0391: ED5B4A80		ld		de,(buffer_Input)
0395: ED537581		ld		(MON_Command),de
              	
0399:         	CheckCmdLength:
              		; Assume argument starts at buffer_Input+3
0399: 3E03    		ld		a,3
039B: 327981  		ld		(MON_ArgStartsAt),a
              	
              		; Is the second byte of the command register 0x20? 
              		; If so, the argument starts at buffer_Input+2.
039E: 3A7681  		ld		a,(MON_Command+1)
03A1: FE20    		cp		$20
03A3: 2005    		jr		nz,GotCmdLength
03A5: 3E02    		ld		a,2
03A7: 327981  		ld		(MON_ArgStartsAt),a
              	
03AA:         	GotCmdLength:
03AA: 060A    		ld		b,10
03AC: CDCF05  		call	GetArgument
03AF: CD6C05  		call	CmdDebugOutput
              	
03B2: CD2908  		call	Monitor_InterpretCommand
              	
              	; Loop...
03B5:         	InputLoopEnd:
03B5: 110C03  		ld		de,strCRLF
03B8: 0E01    		ld		c,B_STROUT
              		DoBIOS
03BA: E7      			rst	$20
03BB: 110C03  		ld		de,strCRLF
03BE: 0E01    		ld		c,B_STROUT
              		DoBIOS
03C0: E7      			rst	$20
03C1: C37C03  		jp		GetInputString
              	
              	;;;;;;;;
              	
03C4:         	ConvertStringToHex8:
              	; Convert the string in StringToHex_Source to a 8-bit hex value.
              	#local
03C4: DD214981		ld		ix,StringToHex_Source
03C8: FD215981		ld		iy,StringToHex_Dest
              	
03CC:         	DoConversion:
03CC:         	Digit0:
              		; Less than $40? Subtract $30.
              		; More than $40? Subtract $40.
03CC: DD7E00  		ld		a,(ix+0)
03CF: FE40    		cp		$40
03D1: FAE303  		jp		m,Digit0_IsNumber
              	
03D4:         	Digit0_IsAlpha:
03D4: C6C9    		add		a,-$37
03D6: CB27    		sla		a
03D8: CB27    		sla		a
03DA: CB27    		sla		a
03DC: CB27    		sla		a
03DE: FD7700  		ld		(iy+0),a
03E1: 180F    		jr		Digit1
              	
03E3:         	Digit0_IsNumber:
03E3: C6D0    		add		a,-$30
03E5: CB27    		sla		a
03E7: CB27    		sla		a
03E9: CB27    		sla		a
03EB: CB27    		sla		a
03ED: FD7700  		ld		(iy+0),a
03F0: 1800    		jr		Digit1
              	
03F2:         	Digit1:
              		; Less than $40? Subtract $30.
              		; More than $40? Subtract $40.
03F2: DD7E01  		ld		a,(ix+1)
03F5: FE40    		cp		$40
03F7: FA0404  		jp		m,Digit1_IsNumber
              	
03FA:         	Digit1_IsAlpha:
03FA: C6C9    		add		a,-$37
03FC: FDB600  		or		(iy+0)
03FF: FD7700  		ld		(iy+0),a
0402: 1808    		jr		Done
              	
0404:         	Digit1_IsNumber:
0404: C6D0    		add		a,-$30
0406: FDB600  		or		(iy+0)
0409: FD7700  		ld		(iy+0),a
              	
040C:         	Done:
040C: C9      		ret
              	#endlocal
              	
              	;;;;;;;;
040D:         	ConvertStringToHex16:
              	; Convert the string in StringToHex_Source to a 16-bit hex value.
              	#local
040D: DD214981		ld		ix,StringToHex_Source
0411: FD215981		ld		iy,StringToHex_Dest
              	
              		; Right-justify the value and add leading zeroes.
0415:         	JustifyLoop:
0415: DD7E03  		ld		a,(ix+3)
0418: FE00    		cp		0
041A: 2019    		jr		nz,DoConversion
041C: DD7E02  		ld		a,(ix+2)
041F: DD7703  		ld		(ix+3),a
0422: DD7E01  		ld		a,(ix+1)
0425: DD7702  		ld		(ix+2),a
0428: DD7E00  		ld		a,(ix+0)
042B: DD7701  		ld		(ix+1),a
042E: 3E30    		ld		a,$30		; ASCII 0
0430: DD7700  		ld		(ix+0),a
0433: 18E0    		jr		JustifyLoop
              	
0435:         	DoConversion:
0435:         	Digit0:
              		; Less than $40? Subtract $30.
              		; More than $40? Subtract $40.
0435: DD7E00  		ld		a,(ix+0)
0438: FE40    		cp		$40
043A: F24004  		jp		p,Digit0_IsAlpha
043D: FA4F04  		jp		m,Digit0_IsNumber
              	
0440:         	Digit0_IsAlpha:
0440: C6C9    		add		a,-$37
0442: CB27    		sla		a
0444: CB27    		sla		a
0446: CB27    		sla		a
0448: CB27    		sla		a
044A: FD7701  		ld		(iy+1),a
044D: 180F    		jr		Digit1
              	
044F:         	Digit0_IsNumber:
044F: C6D0    		add		a,-$30
0451: CB27    		sla		a
0453: CB27    		sla		a
0455: CB27    		sla		a
0457: CB27    		sla		a
0459: FD7701  		ld		(iy+1),a
045C: 1800    		jr		Digit1
              	
045E:         	Digit1:
              		; Less than $40? Subtract $30.
              		; More than $40? Subtract $40.
045E: DD7E01  		ld		a,(ix+1)
0461: FE40    		cp		$40
0463: F26904  		jp		p,Digit1_IsAlpha
0466: FA7304  		jp		m,Digit1_IsNumber
              	
0469:         	Digit1_IsAlpha:
0469: C6C9    		add		a,-$37
046B: FDB601  		or		(iy+1)
046E: FD7701  		ld		(iy+1),a
0471: 180A    		jr		Digit2
              	
0473:         	Digit1_IsNumber:
0473: C6D0    		add		a,-$30
0475: FDB601  		or		(iy+1)
0478: FD7701  		ld		(iy+1),a
047B: 1800    		jr		Digit2
              	
047D:         	Digit2:
              		; Less than $40? Subtract $30.
              		; More than $40? Subtract $40.
047D: DD7E02  		ld		a,(ix+2)
0480: FE40    		cp		$40
0482: F28804  		jp		p,Digit2_IsAlpha
0485: FA9704  		jp		m,Digit2_IsNumber
              	
0488:         	Digit2_IsAlpha:
0488: C6C9    		add		a,-$37
048A: CB27    		sla		a
048C: CB27    		sla		a
048E: CB27    		sla		a
0490: CB27    		sla		a
0492: FD7701  		ld		(iy+1),a
0495: 180F    		jr		Digit3
              	
0497:         	Digit2_IsNumber:
0497: C6D0    		add		a,-$30
0499: CB27    		sla		a
049B: CB27    		sla		a
049D: CB27    		sla		a
049F: CB27    		sla		a
04A1: FD7700  		ld		(iy+0),a
04A4: 1800    		jr		Digit3
              	
04A6:         	Digit3:
              		; Less than $40? Subtract $30.
              		; More than $40? Subtract $40.
04A6: DD7E03  		ld		a,(ix+3)
04A9: FE40    		cp		$40
04AB: F2B104  		jp		p,Digit3_IsAlpha
04AE: FABB04  		jp		m,Digit3_IsNumber
              	
04B1:         	Digit3_IsAlpha:
04B1: C6C9    		add		a,-$37
04B3: FDB600  		or		(iy+0)
04B6: FD7700  		ld		(iy+0),a
04B9: 180A    		jr		Done
              	
04BB:         	Digit3_IsNumber:
04BB: C6D0    		add		a,-$30
04BD: FDB600  		or		(iy+0)
04C0: FD7700  		ld		(iy+0),a
04C3: 1800    		jr		Done
              	
04C5:         	Done:
04C5: C9      		ret
              	#endlocal
              	;;;;;;;;
              	
              	;;;;;;;;
04C6:         	ConvertHex16ToString:
              		; Convert the value in HexToString_Source to ASCII characters.
04C6: DD216181		ld		ix,HexToString_Source
04CA: FD216581		ld		iy,HexToString_Dest
              	
04CE: 210000  		ld		hl,0
04D1: FD7500  		ld		(iy+0),hl
04D4: FD7401  	
04D7: FD7502  		ld		(iy+2),hl
04DA: FD7403  	
              	
              		; A
04DD: DD7E01  		ld		a,(ix+1)
04E0: E6F0    		and		$F0		; now we only have A
04E2: CB3F    		srl		a
04E4: CB3F    		srl		a
04E6: CB3F    		srl		a
04E8: CB3F    		srl		a
04EA: C690    		add  	a,$90
04EC: 27      		daa
04ED: CE40    		adc  	a,$40
04EF: 27      		daa
04F0: FD7700  		ld		(iy+0),a
              	
              		; B
04F3: DD7E01  		ld		a,(ix+1)
04F6: E60F    		and		$0F		; now we only have B
04F8: C690    		add  	a,$90
04FA: 27      		daa
04FB: CE40    		adc  	a,$40
04FD: 27      		daa
04FE: FD7701  		ld		(iy+1),a
              	
              		; C
0501: DD7E00  		ld		a,(ix)
0504: E6F0    		and		$F0		; now we only have C
0506: CB3F    		srl		a	
0508: CB3F    		srl		a
050A: CB3F    		srl 	a
050C: CB3F    		srl 	a
050E: C690    		add  	a,$90
0510: 27      		daa
0511: CE40    		adc  	a,$40
0513: 27      		daa
0514: FD7702  		ld		(iy+2),a
              	
              		; D
0517: DD7E00  		ld		a,(ix)
051A: E60F    		and		$0F		; now we only have D
051C: C690    		add  	a,$90
051E: 27      		daa
051F: CE40    		adc  	a,$40
0521: 27      		daa
0522: FD7703  		ld		(iy+3),a
              	
0525: 3E00    		ld		a,0
0527: FD7704  		ld		(iy+4),a
              	
052A: C9      		ret
              	
              	;;;
052B:         	ConvertHex8ToString:
              		; Convert the value in HexToString_Source to ASCII characters.
              		; A
052B: FD216581		ld		iy,HexToString_Dest
052F: DD216181		ld		ix,HexToString_Source
              	
0533: 210000  		ld		hl,0
0536: FD7500  		ld		(iy+0),hl
0539: FD7401  	
053C: FD7502  		ld		(iy+2),hl
053F: FD7403  	
              	
0542: DD7E00  		ld		a,(ix)
0545: E6F0    		and		$F0		; now we only have A
0547: CB3F    		srl		a	
0549: CB3F    		srl		a
054B: CB3F    		srl 	a
054D: CB3F    		srl 	a
054F: C690    		add  	a,$90
0551: 27      		daa
0552: CE40    		adc  	a,$40
0554: 27      		daa
0555: FD7700  		ld		(iy+0),a
              	
              		; B
0558: DD7E00  		ld		a,(ix)
055B: E60F    		and		$0F		; now we only have B
055D: C690    		add  	a,$90
055F: 27      		daa
0560: CE40    		adc  	a,$40
0562: 27      		daa
0563: FD7701  		ld		(iy+1),a
              	
0566: 3E00    		ld		a,0
0568: FD7702  		ld		(iy+2),a
              	
056B: C9      		ret
              	
              	;;;;;;;;
056C:         	CmdDebugOutput:
056C: 114903  		ld		de,strDbgCmd
056F: 0E01    		ld		c,B_STROUT
              		DoBIOS
0571: E7      			rst	$20
0572: DD2A7581		ld		ix,(MON_Command)
0576: DD5D    		ld		e,ixl
0578: 0E00    		ld		c,B_CONOUT
              		DoBIOS
057A: E7      			rst	$20
057B: DD5C    		ld		e,ixh
057D: 0E00    		ld		c,B_CONOUT
              		DoBIOS
057F: E7      			rst	$20
0580: 110C03  		ld		de,strCRLF
0583: 0E01    		ld		c,B_STROUT
              		DoBIOS
0585: E7      			rst	$20
              	
0586: 115303  		ld		de,strDbgArg
0589: 0E01    		ld		c,B_STROUT
              		DoBIOS
058B: E7      			rst	$20
058C: 110088  		ld		de,MON_Argument1
058F: 0E01    		ld		c,B_STROUT
              		DoBIOS
0591: E7      			rst	$20
0592: 110C03  		ld		de,strCRLF
0595: 0E01    		ld		c,B_STROUT
              		DoBIOS
0597: E7      			rst	$20
0598: 115303  		ld		de,strDbgArg
059B: 0E01    		ld		c,B_STROUT
              		DoBIOS
059D: E7      			rst	$20
059E: 111088  		ld		de,MON_Argument2
05A1: 0E01    		ld		c,B_STROUT
              		DoBIOS
05A3: E7      			rst	$20
05A4: 110C03  		ld		de,strCRLF
05A7: 0E01    		ld		c,B_STROUT
              		DoBIOS
05A9: E7      			rst	$20
05AA: 115303  		ld		de,strDbgArg
05AD: 0E01    		ld		c,B_STROUT
              		DoBIOS
05AF: E7      			rst	$20
05B0: 112088  		ld		de,MON_Argument3
05B3: 0E01    		ld		c,B_STROUT
              		DoBIOS
05B5: E7      			rst	$20
05B6: 110C03  		ld		de,strCRLF
05B9: 0E01    		ld		c,B_STROUT
              		DoBIOS
05BB: E7      			rst	$20
05BC: 115303  		ld		de,strDbgArg
05BF: 0E01    		ld		c,B_STROUT
              		DoBIOS
05C1: E7      			rst	$20
05C2: 113088  		ld		de,MON_Argument4
05C5: 0E01    		ld		c,B_STROUT
              		DoBIOS
05C7: E7      			rst	$20
05C8: 110C03  		ld		de,strCRLF
05CB: 0E01    		ld		c,B_STROUT
              		DoBIOS
05CD: E7      			rst	$20
              	
05CE: C9      		ret
              	
              	;;;;;;;;;;;;;;;;;;
05CF:         	GetArgument:
              	#local
              		; Clear the 4 argument buffers.
05CF: 0640    		ld		b,16*4
05D1: 3E00    		ld		a,0
05D3: 210088  		ld		hl,MON_Argument1
05D6:         	1$:
05D6: 3600    		ld		(hl),0
05D8: 23      		inc		hl
05D9: 10FB    		djnz	1$
              	
              		; Copy from buffer_Input+MON_ArgStartsAt into the argument buffers.
              		; Max 4 space-delimited arguments.
05DB: 110088  		ld		de,MON_Argument1	; <-- MUST BE PAGE ALIGNED FOR POINTER MATH TO WORK!
05DE: 214A80  		ld		hl,buffer_Input
05E1: DD210088		ld		ix,MON_Argument1
              	
05E5: 3A7981  		ld		a,(MON_ArgStartsAt)
05E8: 4F      		ld		c,a
05E9: 0600    		ld		b,0		; BC is now ArgStartsAt
05EB: 09      		add		hl,bc	; And HL is now the beginning of the arguments.
              	
              		; HL is now the beginning of the argument.
              		; DE is now the destination address.
05EC:         	ArgumentCopyLoop:
              		; Copy until we find a SPC. A CR/LF advances to the next argument buffer.
              		; Only 4 arguments are supported.
05EC: 7E      		ld		a,(hl)
05ED: 23      		inc		hl
05EE: FE0D    		cp		$0D
05F0: 2813    		jr		z,done
05F2: FE20    		cp		$20
05F4: 200B    		jr		nz,copychar
              		
              		; Advance to the next argument.
05F6: DD7D    		ld		a,ixl
05F8: C610    		add		a,16
05FA: 5F      		ld		e,a
05FB: C610    		add		a,16
05FD: DD6F    		ld		ixl,a
              	
05FF: 18EB    		jr		ArgumentCopyLoop
              	
0601:         	copychar:
0601: 12      		ld		(de),a
0602: 13      		inc		de
0603: 10E7    		djnz	ArgumentCopyLoop
              	
0605:         	done:
0605: C9      		ret
              	#endlocal
              	
              	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0606:         	ClearInputBuffer:
0606: 3E00    		ld		a,0
0608: 214A80  		ld		hl,buffer_Input
060B:         	1$:
060B: 3600    		ld		(hl),0
060D: 23      		inc		hl
060E: 3C      		inc		a
060F: FEFF    		cp		$FF
0611: 20F8    		jr		nz,1$
0613: C9      		ret
              	
              	#include "commands/memory.asm"
              	; Monitor's M command - memory output
0614:         	Monitor_CMD_Memory:
              		; Load the arguments into MemoryOutputStartAddr/MemoryOutputEndAddr.
              	    
              	    ; Beginning address
0614: 2A0088  		ld		hl,(MON_Argument1+0)
0617: 224981  		ld		(StringToHex_Source+0),hl
061A: 2A0288  		ld		hl,(MON_Argument1+2)
061D: 224B81  		ld		(StringToHex_Source+2),hl
              	
0620: CD0D04  		call	ConvertStringToHex16
0623: 2A5981  		ld		hl,(StringToHex_Dest)
0626: 226981  		ld		(MemoryOutputStartAddr),hl
              	
              		; Ending address
0629: 2A1088  		ld		hl,(MON_Argument2)
062C: 224981  		ld		(StringToHex_Source+0),hl
062F: 2A1288  		ld		hl,(MON_Argument2+2)
0632: 224B81  		ld		(StringToHex_Source+2),hl
0635: CD0D04  		call	ConvertStringToHex16
              	
0638: 2A5981  		ld		hl,(StringToHex_Dest)
063B: 226D81  		ld		(MemoryOutputEndAddr),hl
063E: CD8306  		call	Monitor_DoMemoryOutput
              	
0641: C9      		ret
              	
0642:         	Monitor_DoMemoryLabel:
              		; Formatting: start address
0642: 2A6B81  		ld		hl,(MemoryOutputCurAddr)
0645: 226181  		ld		(HexToString_Source),hl
0648: CDC604  		call	ConvertHex16ToString
064B: 116581  		ld		de,HexToString_Dest
064E: 0E01    		ld		c,B_STROUT
              		DoBIOS
0650: E7      			rst	$20
0651: 1E3A    		ld		e,":"
0653: 0E00    		ld		c,B_CONOUT
              		DoBIOS
0655: E7      			rst	$20
0656: 1E20    		ld		e," "
0658: 0E00    		ld		c,B_CONOUT
              		DoBIOS
065A: E7      			rst	$20
065B: C9      		ret
              	
065C:         	Monitor_PrintBytes:
              		; Input:
              		; B  - how many bytes to dump
              		; IX - pointer to start of memory area to dump
065C: C5      		push	bc
              	
065D: DD7E00  		ld		a,(ix)						; A has a memory byte
0660: 326181  		ld		(HexToString_Source),a		
0663: DDE5    		push	ix
0665: CD2B05  		call	ConvertHex8ToString			; Convert it to ASCII
              	
              		; Print two characters of output and a space
0668: 3A6581  		ld		a,(HexToString_Dest)
066B: 5F      		ld		e,a
066C: 0E00    		ld		c,B_CONOUT
              		DoBIOS								
066E: E7      			rst	$20
066F: 3A6681  		ld		a,(HexToString_Dest+1)
0672: 5F      		ld		e,a
0673: 0E00    		ld		c,B_CONOUT
              		DoBIOS
0675: E7      			rst	$20
0676: 1E20    		ld		e," "
0678: 0E00    		ld		c,B_CONOUT
              		DoBIOS
067A: E7      			rst	$20
              	
              		; Advance the memory source pointer. Continue until B == 0.
067B: DDE1    		pop		ix
067D: DD23    		inc		ix
              	
067F: C1      		pop		bc
0680: 10DA    		djnz	Monitor_PrintBytes
              	
0682: C9      		ret
              	
0683:         	Monitor_DoMemoryOutput:
              	#local
0683: 2A6981  		ld		hl,(MemoryOutputStartAddr)
0686: 226B81  		ld		(MemoryOutputCurAddr),hl
              	
0689: CD4206  		call	Monitor_DoMemoryLabel
              	
              		; Output 16 memory bytes
068C: 2A6D81  		ld		hl,(MemoryOutputEndAddr)
068F: ED4B6981		ld		bc,(MemoryOutputStartAddr)
0693: 37      		scf
0694: 3F      		ccf		; Clear carry flag to get the proper subtraction result.
0695: 23      		inc		hl	
0696: ED42    		sbc		hl,bc
0698: 226F81  		ld		(MemoryOutputBytesLeft),hl
              	
069B: DD2A6981		ld		ix,(MemoryOutputStartAddr)
069F: 0610    		ld		b,16
06A1: CD5C06  		call	Monitor_PrintBytes
              	
06A4:         	EndMemoryLine:
06A4: 110C03  		ld		de,strCRLF
06A7: 0E01    		ld		c,B_STROUT
              		DoBIOS
06A9: E7      			rst	$20
              	
06AA: 2A6F81  		ld		hl,(MemoryOutputBytesLeft)
06AD: 37      		scf
06AE: 011000  		ld		bc,16
06B1: ED42    		sbc		hl,bc	; Subtract the 16 bytes we already read.
06B3: FAD206  		jp		m,Done	; End if we're out of memory to write.
06B6: 226F81  		ld		(MemoryOutputBytesLeft),hl
              	
06B9: 011000  		ld		bc,16
06BC: 2A6B81  		ld		hl,(MemoryOutputCurAddr)
06BF: 09      		add		hl,bc						; Advance start pointer
06C0: 226B81  		ld		(MemoryOutputCurAddr),hl	
06C3: CD4206  		call	Monitor_DoMemoryLabel
              	
06C6: 0610    		ld		b,16						; Another 16 bytes
06C8: DD2A6B81		ld		ix,(MemoryOutputCurAddr)
06CC: CD5C06  		call	Monitor_PrintBytes
06CF: C3A406  		jp		EndMemoryLine
              	
06D2:         	Done:
06D2: C9      		ret
              	#endlocal
              	#include "commands/go.asm"
              	; Monitor's G command - Go
              	; JP to an address.
06D3:         	Monitor_CMD_Go:
              	    ; Beginning address
06D3: 2A0088  		ld		hl,(MON_Argument1+0)
06D6: 224981  		ld		(StringToHex_Source+0),hl
06D9: 2A0288  		ld		hl,(MON_Argument1+2)
06DC: 224B81  		ld		(StringToHex_Source+2),hl
              	
06DF: CD0D04  		call	ConvertStringToHex16
06E2: 2A5981  		ld		hl,(StringToHex_Dest)
06E5: E9      	    jp      (hl)
              	
06E6: C9      		ret
              	#include "commands/upload.asm"
              	; Monitor's U command
              	; Upload a HEX file somewhere in memory
              	#local
06E7:         	Monitor_CMD_Upload::
              	    ; Each HEX record contains the destination address.
06E7: 2A0088  	    ld		hl,(MON_Argument1+0)
06EA: 224981  		ld		(StringToHex_Source+0),hl
06ED: 2A0288  		ld		hl,(MON_Argument1+2)
06F0: 224B81  		ld		(StringToHex_Source+2),hl
              	
06F3: CD0D04  		call	ConvertStringToHex16
06F6: 2A5981  		ld		hl,(StringToHex_Dest)
06F9: 220280  	    ld      (HEX_BaseAddress),hl
              	
06FC: 11AC07  		ld		de,STR_HEX_ReadyToReceive
06FF: 0E01    		ld		c,B_STROUT
              		DoBIOS
0701: E7      			rst	$20
              	
              	    ; Receive one record.
0702: CD4307  	    call    HEX_ReceiveRecord
              	
              	    ; Is it an EOF?
0705: 3A0680  	    ld      a,(HEX_RecordType)
0708: FE01    	    cp      1    
070A: 2805    	    jr      z,Done
              	
              	    ; Copy it to its destination.
070C: CD1207  	    call    HEX_CopyRecord
070F: 18D6    	    jr      Monitor_CMD_Upload
              	
0711:         	Done:
0711: C9      		ret
              	#endlocal
              	
0712:         	HEX_CopyRecord:
0712: ED5B0480	    ld      de,(HEX_Address)
0716: 2A0280  	    ld      hl,(HEX_BaseAddress)
0719: 19      	    add     hl,de   ; HL is now base address + offset. We can't do 16-bit math in DE. :(
071A: 545D    	    ld      de,hl
              	
071C: 210780  	    ld      hl,HEX_RecordData
071F: 3A0180  	    ld      a,(HEX_BytesInRecord)
0722: 4F      	    ld      c,a
0723: 0600    	    ld      b,0
0725: EDB0    	    ldir
0727: C9      	    ret
              	
0728:         	HEX_GetASCIIByteValue:
              	    ; Get two ASCII characters, convert them to a byte value, and return it in A.
0728: 0E02    	    ld		c,B_CONIN
              	    DoBIOS
072A: E7      			rst	$20
072B: 324981  		ld		(StringToHex_Source+0),a
072E: 0E02    	    ld		c,B_CONIN
              	    DoBIOS
0730: E7      			rst	$20
0731: 324A81  		ld		(StringToHex_Source+1),a
              	
0734: CDC403  		call	ConvertStringToHex8
0737: 3A5981  		ld		a,(StringToHex_Dest)
073A: C9      	    ret
              	
073B:         	HEX_AwaitStartCode:
              	    ; Listen for the start code.
073B: 0E02    	    ld		c,B_CONIN
              	    DoBIOS
073D: E7      			rst	$20
              	
073E: FE3A    	    cp      ":"
0740: 20F9    	    jr      nz,HEX_AwaitStartCode
              	
              	    ; Got the start code of a HEX.
0742: C9      	    ret
              	
0743:         	HEX_ReceiveRecord:
              	    ; Receive a HEX record.
              	
              	    ; Set up our variables.
0743: 3E00    	    ld      a,0
0745: 320080  	    ld      (HEX_GotStartCode),a
0748: 320180  	    ld      (HEX_BytesInRecord),a
              	
074B: CD3B07  	    call    HEX_AwaitStartCode
074E: 210080  	    ld      hl,HEX_GotStartCode
0751: 34      	    inc     (hl)
              	
0752: 11C407  	    ld		de,STR_HEX_Debug_GotStart
0755: 0E01    		ld		c,B_STROUT
              		DoBIOS
0757: E7      			rst	$20
              	
              	    ; Next up is the number of bytes contained in this record.
0758: CD2807  	    call    HEX_GetASCIIByteValue
075B: 320180  	    ld      (HEX_BytesInRecord),a
              	
075E: 11D507  		ld		de,STR_HEX_Debug_GotLength
0761: 0E01    		ld		c,B_STROUT
              		DoBIOS
0763: E7      			rst	$20
              	
              	    ; Then a big-endian address.
0764: CD2807  	    call    HEX_GetASCIIByteValue
0767: 67      	    ld      h,a
0768: E5      	    push    hl
0769: CD2807  	    call    HEX_GetASCIIByteValue
076C: E1      	    pop     hl
076D: 6F      	    ld      l,a
076E: 220480  	    ld      (HEX_Address),hl
              	
0771: 11E607  	    ld		de,STR_HEX_Debug_GotAddr
0774: 0E01    		ld		c,B_STROUT
              		DoBIOS
0776: E7      			rst	$20
              	
              	    ; Then the record type.
0777: CD2807  	    call    HEX_GetASCIIByteValue
077A: 320680  	    ld      (HEX_RecordType),a
              	
077D: 11F807  		ld		de,STR_HEX_Debug_GotType
0780: 0E01    		ld		c,B_STROUT
              		DoBIOS
0782: E7      			rst	$20
              	
              	    ; Then the record data itself.
0783: 3A0180  	    ld      a,(HEX_BytesInRecord)
0786: FE00    	    cp      0
0788: 2815    	    jr      z,HEX_GetChecksum
              	
078A: 47      	    ld      b,a
078B: 210780  	    ld      hl,HEX_RecordData
              	
078E:         	ReceiveLoop:
078E: C5      	    push    bc
078F: E5      	    push    hl
              	
0790: CD2807  	    call    HEX_GetASCIIByteValue
              	    
0793: E1      	    pop     hl 
0794: C1      	    pop     bc
              	
0795: 77      	    ld      (hl),a
0796: 23      	    inc     hl          ; Advance receive buffer
0797: 10F5    	    djnz    ReceiveLoop ; Loop until receive count is 0
              	
0799: 110708  		ld		de,STR_HEX_Debug_GotData
079C: 0E01    		ld		c,B_STROUT
              		DoBIOS
079E: E7      			rst	$20
              	
079F:         	HEX_GetChecksum:
              	    ; And finally the checksum.
079F: CD2807  	    call    HEX_GetASCIIByteValue
07A2: 324780  	    ld      (HEX_Checksum),a
              	
07A5: 111608  		ld		de,STR_HEX_Debug_GotChecksum
07A8: 0E01    		ld		c,B_STROUT
              		DoBIOS
07AA: E7      			rst	$20
              	
07AB: C9      	    ret
              	
              	#data DATA
8000: 00      	HEX_GotStartCode:   .db 0   ; Did we get the start code?
8001: 00      	HEX_BytesInRecord:  .db 0   ; How many bytes does this record contain?
8002: 0000    	HEX_BaseAddress:    .dw 0   ; Base address to write to. The record's offset is added to it.
              	
              	; The record itself.
8004: 0000    	HEX_Address:        .dw 0   ; WORD  - Destination address, always big-endian.
8006: 00      	HEX_RecordType:     .db 0   ; BYTE  - Record type.
8007: 00000000	HEX_RecordData:     .ds 64  ; ARRAY - The record's contents.
800B: 00...   	HEX_RecordData:     .ds 64  ; ARRAY - The record's contents.
8047: 00      	HEX_Checksum:       .db 0   ; BYTE  - Checksum of the record.
              	
              	#code _CODE
07AC: 52656164	STR_HEX_ReadyToReceive: .ascii "Ready to receive HEX.",13,10,0
07B0: 7920746F	
07B4: 20726563	
07B8: 65697665	
07BC: 20484558	
07C0: 2E0D0A00	
07C4: 476F7420	STR_HEX_Debug_GotStart: .ascii "Got start code",13,10,0
07C8: 73746172	
07CC: 7420636F	
07D0: 64650D0A	
07D4: 00      	
07D5: 476F7420	STR_HEX_Debug_GotLength: .ascii "Got rec length",13,10,0
07D9: 72656320	
07DD: 6C656E67	
07E1: 74680D0A	
07E5: 00      	
07E6: 476F7420	STR_HEX_Debug_GotAddr: .ascii "Got rec address",13,10,0
07EA: 72656320	
07EE: 61646472	
07F2: 6573730D	
07F6: 0A00    	
07F8: 476F7420	STR_HEX_Debug_GotType: .ascii "Got rec type",13,10,0
07FC: 72656320	
0800: 74797065	
0804: 0D0A00  	
0807: 476F7420	STR_HEX_Debug_GotData: .ascii "Got rec data",13,10,0
080B: 72656320	
080F: 64617461	
0813: 0D0A00  	
0816: 476F7420	STR_HEX_Debug_GotChecksum: .ascii "Got rec checksum",13,10,0
081A: 72656320	
081E: 63686563	
0822: 6B73756D	
0826: 0D0A00  	
              	
              	#code	_CODE
              	
              	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0829:         	Monitor_InterpretCommand:
              		; The Z80 version of a switch statement?
0829: 3A7581  		ld		a,(MON_Command)
              	
              		; JP to the command that matches. 
              		; If no command matches, fall through to an error.
              		; The command's RET will return to *this function's caller*
              		; i.e. the command loop.
              	
              		; Command: Memory
082C: FE4D    		cp		"M"
082E: CA1406  		jp		z,Monitor_CMD_Memory
              	
0831: FE47    		cp		"G"
0833: CAD306  		jp		z,Monitor_CMD_Go
              	
0836: FE55    		cp		"U"
0838: CAE706  		jp		z,Monitor_CMD_Upload
              	
083B: 115D03  		ld		de,strCmdUnknown
083E: 0E01    		ld		c,B_STROUT
              		DoBIOS
0840: E7      			rst	$20
0841: 110C03  		ld		de,strCRLF
0844: 0E01    		ld		c,B_STROUT
              		DoBIOS
0846: E7      			rst	$20
              	
0847: C9      		ret
              	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
              	
              	#data	DATA	; Data section in RAM. Assume 32K of RAM on an RC2014.
              	
8048:         	buffer_base:
8048: 00      	buffer_len:				.db 0
8049: 00      	buffer_inputsize:		.db 0
804A: 00000000	buffer_Input:			.ds	255	; 255 bytes of input storage
804E: 00...   	buffer_Input:			.ds	255	; 255 bytes of input storage
              	
              	;;;
8149: 00000000	StringToHex_Source:		.ds 16
814D: 00...   	StringToHex_Source:		.ds 16
8159: 00000000	StringToHex_Dest:		.ds 8
815D: 00000000	StringToHex_Dest:		.ds 8
              	
8161: 00000000	HexToString_Source:		.ds	4
8165: 00000000	HexToString_Dest:		.ds 4
              	
              	;;;
8169: 0000    	MemoryOutputStartAddr:	.dw 0
816B: 0000    	MemoryOutputCurAddr:	.dw 0
816D: 0000    	MemoryOutputEndAddr:	.dw 0
816F: 0000    	MemoryOutputBytesLeft:	.dw 0
              	
              	;;;
8171: 0000    	HEX_DestinationAddr:	.dw 0
              	
              	;;;;;;;;;;;;;;;;;;;
              	; ROM monitor data stuff
8173: 0000    	MON_PreviousCmd:	.db		0,0
8175: 0000    	MON_Command:		.db		0,0
              	
8177: 0000    	MON_ArgDestPtr:		.dw		0
8179: 00      	MON_ArgStartsAt: 	.db		0
817A: 00000000		.org $8800			; ensure these are page-aligned
817E: 00...   		.org $8800			; ensure these are page-aligned
8800: 00000000	MON_Argument1:		.ds		16
8804: 00...   	MON_Argument1:		.ds		16
8810: 00000000	MON_Argument2:		.ds		16
8814: 00...   	MON_Argument2:		.ds		16
8820: 00000000	MON_Argument3:		.ds		16
8824: 00...   	MON_Argument3:		.ds		16
8830: 00000000	MON_Argument4:		.ds		16
8834: 00...   	MON_Argument4:		.ds		16
              	
              	#end


total time: 0.5154 sec.
no errors
