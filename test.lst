              	; --------------------------------------
              	; zasm: assemble "test.asm"
              	; date: 2020-02-02 02:13:08
              	; --------------------------------------


              	#target rom
              	
              	#include "bios.inc"
0000:         	B_CONOUT        = 0
0001:         	B_STROUT        = 1
0002:         	B_CONIN         = 2
0003:         	B_CONSTAT       = 3
0004:         	B_STRIN         = 4
              	
              		;; SIO equates
0081:         	SIOA_D	.EQU $81
0080:         	SIOA_C	.EQU $80
0083:         	SIOB_D	.EQU $83
0082:         	SIOB_C	.EQU $82
              		
0000:         	#code	_BOOT,0h,200h		; Reset vector, RST vectors, NMI vectors
              	
              		;;  see rc2014init.asm
              		
0000: F3      	RST00:	di			; interrupts off
0001: C33C03  			jp	Start
0004: 00      			nop
0005: 00      			nop
0006: 00      			nop
0007: 00      			nop			
              	
0008: C31B02  	RST08:	jp	rc2014_sio_TX	; 0x08
000B: 00      			nop
000C: 00      			nop
000D: 00      			nop
000E: 00      			nop
000F: 00      			nop
              	
0010: C30002  	RST10:	jp	rc2014_getc	; 0x10
0013: 00      			nop
0014: 00      			nop
0015: 00      			nop
0016: 00      			nop
0017: 00      			nop
              	
0018: C31102  	RST18:	jp	rc2014_pollc	; 0x18
001B: 00      			nop
001C: 00      			nop
001D: 00      			nop
001E: 00      			nop
001F: 00      			nop
              	
0020: C35502  	RST20:	jp	B_Dispatch	; 0x20
0023: 00      			nop
0024: 00      			nop
0025: 00      			nop
0026: 00      			nop
0027: 00      			nop
              	
0028: C9      	RST28:	ret
0029: 00      			nop
002A: 00      			nop
002B: 00      			nop
002C: 00      			nop
002D: 00      			nop
              		
002E: C9      	RST30:	ret
002F: 00      			nop
0030: 00      			nop
0031: 00      			nop
0032: 00      			nop
0033: 00      			nop
              	
0034: ED4D    	RST38:	reti
0036: 00      			nop
0037: 00      			nop
0038: 00      			nop
0039: 00      			nop
003A: 00      			nop
              		
              	;;; ;;;;;;;;;;;;;;;;
              	
0200:         	#code	_CODE,0x200,0x1E00	; 8K page total
              		
              	#include 	"rc2014.asm"
              	DoBIOS	.macro
              			rst	$20
              			.endm
              	
              	;;; rc2014_getc
              	;;; Wait for the UART to receive a character.
              	;;; Return the character in HL.
0200:         	rc2014_getc:
0200: F5      	        push 	af
0201: DB80    	waitch:	in 	a,(SIOA_C)
0203: CB47    	        bit 	0,a
0205: 28FA    	        jr 	z,waitch
0207: DB81    	        in 	a,(SIOA_D)
0209: 2600    	        ld 	h,0
020B: 6F      	        ld 	l,a
020C: F1      	        pop 	af
020D: C9      	        ret
              	
              	;;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
              	;;; rc2014_putc
              	;;; Output the byte in L to the SIO.
              	;;;
020E:         	rc2014_putc:
020E: 7D      		ld	a,l
020F: CF      		rst	$08
0210: C9      		ret
              	
              	;;; rc2014_pollc
              	;;; Poll the UART receive buffer.
              	;;; L <- 1 if data available
              	;;; L <- 0 if no data available
0211:         	rc2014_pollc:
0211: 2E00    		ld	l,0
0213: DB80    		in	a,(SIOA_C)
0215: CB47    		bit	0,a
0217: C8      		ret	z
0218: 2E01    		ld	l,1
021A: C9      		ret
              	
              	;;; ;;;;;;;;;;;;;
021B:         	rc2014_sio_TX:
              	#local
021B: F5      		push af
021C: DB80    	txbusy: in a,($80)          ; read serial status
021E: CB57    	        bit 2,a             ; check status bit 2
0220: 28FA    	        jr z, txbusy        ; loop if zero (serial is busy)
0222: F1      	        pop af
0223: D381    	        out ($81), a        ; transmit the character
0225: C9      	        ret
              	#endlocal
              	
              	;;; ;;;;;;;;;;;;;
0226:         	rc2014_sio_init:
              	;;; Set up the SIO channel A for UART transmit/receive.
0226: 3E30    		ld	a,00110000b	; WR0: error reset, select WR0
0228: D380    		out	(SIOA_C),a
022A: 3E18    		ld	a,018h		; WR0: reset
022C: D380    		out	(SIOA_C),a
              	
022E: 3E04    		ld	a,04h		; WR0: select WR4
0230: D380    		out	(SIOA_C),a
0232: 3EC4    		ld	a,11000100b	; WR4: CLK/64, 1 stop, N parity (at 2.4MHz, 38400bps)
0234: D380    		out	(SIOA_C),a
              	
0236: 3E05    		ld	a,05h		; WR0: select WR5
0238: D380    		out	(SIOA_C),a
023A: 3EE8    		ld	a,11101000b	; DTR, TX 8bit, no BRK, TX on, no RTS
023C: D380    		out	(SIOA_C),a
              	
023E: 3E01    		ld	a,01h		; WR0: select WR1
0240: D382    		out	(SIOB_C),A
0242: 3E04    		ld	a,00000100b	; No CH B interrupt
              	
0244: 3E01    		ld	a,01h		; WR0: Select WR1
0246: D380    		out	(SIOA_C),A	
0248: 3E00    		ld	a,00h		; WR1: All interrupts off
024A: D380    		out	(SIOA_C),A
              	
              		;; Enable SIO RX on channel A.
024C: 3E03    		ld	a,03h
024E: D380    		out	(SIOA_C),a
0250: 3EC1    		ld	a,0C1h		; RX 8bit, RX on, auto enable off
0252: D380    		out	(SIOA_C),a
              	
0254: C9      		ret
              	
              	;;; ;;;;;;;;;;;;;;;;;
              	;;; BIOS functions
              	;;;
              	;;; API:
              	;;;		All BIOS functions are prefixed with B_
              	;;; 	Input is DE
              	;;;		Output bytes are in A
              	;;;		Output words are in HL (todo: ?)
              	;;;
              	;;;		Do not assume any registers are preserved.
0255:         	B_Dispatch:
              		;; Dispatch to the function number C.
0255: D5      		push	de
0256: F5      		push	af
0257: 21FE02  		ld		hl,BIOS_FnTable	; grab the jump table address
025A: 1600    		ld		d,0		; clear D
              		
025C: CB21    		sla		c		; shift C to produce a table offset
025E: 59      		ld		e,c		; E <- C
025F: 19      		add		hl,de	; Apply the offset.
0260: 5E23562B		ld		de,(hl)	; Get the destination address.
0264: 626B    		ld		hl,de	; Move it into HL so we can jump to it.
              	
0266: F1      		pop		af		; Restore AF and DE.
0267: D1      		pop		de
0268: E9      		jp		(hl)	; Jump to the BIOS function, which RETs back to where we started.
0269: C9      		ret				; Unnecessary unless something breaks
              		
              	;;
026A:         	B_Conout:
              		;; CONsole OUTput.
              		;; 
              		;; Input:
              		;; E - character
026A: 7B      		ld		a,e
026B: CD1B02  		call	rc2014_sio_TX
026E: C9      		ret
              	
              	;;
              	#local
026F:         	B_Strout::
              		;; STRing OUTput.
              		;; Input:
              		;; DE - string address
              		;;
              		;; Perform B_Conout until a 0 is found in the string.
026F:         	1$:	
026F: 1A      		ld		a,(de)
0270: FE00    		cp		#0
0272: 2809    		jr		z,2$
0274: D5      		push	de
0275: 5F      		ld		e,a
0276: CD6A02  		call	B_Conout
0279: D1      		pop		de
027A: 13      		inc		de
027B: 18F2    		jr		1$
              	
027D:         	2$:
027D: C9      		ret	
              	#endlocal	
              	;;
              	
027E:         	B_Conin:
              		;; CONsole INput.
              		;;
              		;; Blocks until a character is available on the console.
              		;; Output:
              		;; A = character received
027E: CD0002  		call	rc2014_getc	; returns char in L
0281: 7D      		ld		a,l			; copy it to A and return
0282: C9      		ret
              		;;
              	
0283:         	B_Constat:
              		;; CONsole STATus.
              		;;
              		;; Output:
              		;; A  = 0 if no characters are waiting to be read
              		;; A != 0 if character is waiting
0283: CD1102  		call	rc2014_pollc
0286: 7D      		ld		a,l
0287: C9      		ret
              	
              	#local
0288:         	B_Strin::
              		;; Read string into buffer.
              		;; Buffer structure is as follows:
              		;;	db buffer_size		- how many characters are allowed
              		;;	db input_length 	- populated after input is complete
              		;;	byte[buffer_size] 	- the input string
              		;;
              		;; Buffer address is placed in DE.
0288: FD62FD6B		ld		iy,de	; Copy buffer base address to IY
028C: FD23    		inc		iy
028E: FD23    		inc		iy		; advance 2 bytes to start of the string buffer
              	
0290: DD210000		ld		ix,0	; clear input length
              	
0294:         	begin:
0294: D7      		rst		$10		; Get an input character.
              	
              		; Check for Ctrl+H
0295: 7D      		ld		a,l
0296: FE08    		cp		$08
0298: 2805    		jr		z,handlebs
              	
029A:         	check2:
              		; Check for 0x7F (some terminals use this instead)
029A: 7D      		ld		a,l
029B: FE7F    		cp		$7F	
029D: 2027    		jr		nz,charout	; Any other character bypasses
              	
029F:         	handlebs:
              		;; Handle the backspace.
029F: DD7D    		ld		a,ixl	; is the input length already 0? if so, ignore and go back to waiting for input
02A1: FE00    		cp		0
02A3: 28EF    		jr		z,begin
              	
              		; Reset the write pointer and length.
02A5: FD2B    		dec		iy
02A7: DD2B    		dec		ix
              	
02A9: D5      		push	de
02AA: E5      		push	hl
02AB: DDE5    		push	ix
02AD: FDE5    		push	iy
02AF: 1E08    		ld		e,$08
02B1: 0E00    		ld		c,B_CONOUT
              		DoBIOS		; console BS
02B3: E7      			rst	$20
02B4: 1E20    		ld		e,$20
02B6: 0E00    		ld		c,B_CONOUT
              		DoBIOS		; console SPC
02B8: E7      			rst	$20
02B9: 1E08    		ld		e,$08
02BB: 0E00    		ld		c,B_CONOUT
              		DoBIOS		; console BS
02BD: E7      			rst	$20
02BE: FDE1    		pop		iy
02C0: DDE1    		pop		ix
02C2: E1      		pop		hl
02C3: D1      		pop		de
02C4: 18CE    		jr		begin	; And we're done.
              	
02C6:         	charout:
              		; write character to buffer
02C6: FD7500  		ld		(iy),l	; copy the character to the input buffer
02C9: FD23    		inc		iy		; advance buffer
02CB: DD23    		inc		ix		; length++
              	
              		; TODO: Length == buffer size? If so, don't allow more characters.
              	
02CD:         	write:	
              		; write character to console
02CD: D5      		push	de
02CE: E5      		push	hl
02CF: DDE5    		push	ix
02D1: FDE5    		push	iy
02D3: 5D      		ld		e,l
02D4: 0E00    		ld		c,B_CONOUT
              		DoBIOS
02D6: E7      			rst	$20
02D7: FDE1    		pop		iy
02D9: DDE1    		pop		ix
02DB: E1      		pop		hl
02DC: D1      		pop		de
              	
              		; Is the character 0x0D?
02DD: 7D      		ld		a,l
02DE: FE0D    		cp		$0D	; LF
02E0: 20B2    		jr		nz,begin		; loop if no
              	
              		; Add a 0x0A
02E2: 2E0A    		ld		l,0x0A
02E4: FD7500  		ld		(iy),l	; copy the character to the input buffer
02E7: FD23    		inc		iy		; advance buffer
02E9: DD23    		inc		ix		; length++
              	
              		; add a null
02EB: 2E00    		ld		l,0
02ED: FD7500  		ld		(iy),l	; copy the character to the input buffer
02F0: FD23    		inc		iy		; advance buffer
02F2: DD23    		inc		ix		; length++
              	
              		; Write the length to the buffer struct
02F4: DD7D    		ld		a,ixl
02F6: FD62FD6B		ld		iy,de
02FA: FD7701  		ld		(iy+1),a
              	
02FD: C9      		ret
              	#endlocal
              	
02FE:         	BIOS_FnTable:
02FE: 6A02    		.dw B_Conout		; C = 0
0300: 6F02    		.dw	B_Strout		; C = 1
0302: 7E02    		.dw	B_Conin			; C = 2
0304: 8302    		.dw	B_Constat		; C = 3
0306: 8802    		.dw	B_Strin			; C = 4
              	#include	"strings.asm"
0308:         	strPrompt:
0308: 3E00    		.asciz	">"
030A:         	strCRLF:
030A: 0D0A00  		.ascii	13,10,0
              	
030D:         	HelloWorld:
030D: 48656C6C		.ascii	"Hello Z80!",13,10,0
0311: 6F205A38	
0315: 30210D0A	
0319: 00      	
              	
031A:         	strYouEntered:
031A: 596F7520		.asciz	"You entered: "
031E: 656E7465	
0322: 7265643A	
0326: 2000    	
              	
0328:         	strDbgCmd:
0328: 436F6D6D	    .asciz  "Command: "
032C: 616E643A	
0330: 2000    	
              	
0332:         	strDbgArg:
0332: 20202020	    .asciz  "    Arg: "
0336: 4172673A	
033A: 2000    	
              		
033C:         	Start:
033C: 21F9FF  		ld		hl,$FFF9	; initialize stack
033F: F9      		ld		sp,hl
              	
0340: F3      		di
0341: CD2602  		call	rc2014_sio_init
              	
0344:         	Greet:
0344: 110D03  		ld		de,HelloWorld
0347: 0E01    		ld		c,B_STROUT
0349: E7      		rst		$20
              	
034A:         	GetInputString:
              		; reset offset
034A: 110803  		ld		de,strPrompt
034D: 0E01    		ld		c,B_STROUT
              		DoBIOS
034F: E7      			rst	$20
              	
0350: CD7904  		call	ClearInputBuffer
0353: 110080  		ld		de,buffer_base
0356: 0E04    		ld		c,B_STRIN
              		DoBIOS
0358: E7      			rst	$20
0359: 110A03  		ld		de,strCRLF
035C: 0E01    		ld		c,B_STROUT
              		DoBIOS
035E: E7      			rst	$20
              	
035F: 111A03  		ld		de,strYouEntered
0362: 0E01    		ld		c,B_STROUT
              		DoBIOS
0364: E7      			rst	$20
0365: 110280  		ld		de,buffer_Input
0368: 0E01    		ld		c,B_STROUT
              		DoBIOS
036A: E7      			rst	$20
036B: 110A03  		ld		de,strCRLF
036E: 0E01    		ld		c,B_STROUT
              		DoBIOS
0370: E7      			rst	$20
              	
              		; Take the first two bytes of buffer_Input and put them in the command register.
0371: ED5B0280		ld		de,(buffer_Input)
0375: ED532981		ld		(MON_Command),de
              	
0379:         	CheckCmdLength:
              		; Assume argument starts at buffer_Input+3
0379: 3E03    		ld		a,3
037B: 323581  		ld		(MON_ArgStartsAt),a
              	
              		; Is the second byte of the command register 0x20? 
              		; If so, the argument starts at buffer_Input+2.
037E: 3A2A81  		ld		a,(MON_Command+1)
0381: FE20    		cp		$20
0383: 2005    		jr		nz,GotCmdLength
0385: 3E02    		ld		a,2
0387: 323581  		ld		(MON_ArgStartsAt),a
              	
038A:         	GotCmdLength:
038A: 060A    		ld		b,10
038C: CD6504  		call	GetArgument
038F: CD3804  		call	CmdDebugOutput
              	
              		; debug: preload some values
0392: 210002  		ld		hl,$0200
0395: 222181  		ld		(MemoryOutputStartAddr),hl
0398: 213F02  		ld		hl,$023F
039B: 222581  		ld		(MemoryOutputEndAddr),hl
039E: CDC804  		call	Monitor_DoMemoryOutput
              	
              	; Loop...
03A1:         	InputLoopEnd:
03A1: 110A03  		ld		de,strCRLF
03A4: 0E01    		ld		c,B_STROUT
              		DoBIOS
03A6: E7      			rst	$20
03A7: 110A03  		ld		de,strCRLF
03AA: 0E01    		ld		c,B_STROUT
              		DoBIOS
03AC: E7      			rst	$20
03AD: C34A03  		jp		GetInputString
              	
              	;;;;;;;;
03B0:         	ConvertHex16ToString:
              		; Convert the value in HexToString_Source to ASCII characters.
03B0: DD211981		ld		ix,HexToString_Source
03B4: FD211D81		ld		iy,HexToString_Dest
              	
              		; A
03B8: DD7E01  		ld		a,(ix+1)
03BB: E6F0    		and		$F0		; now we only have A
03BD: CB3F    		srl		a
03BF: CB3F    		srl		a
03C1: CB3F    		srl		a
03C3: CB3F    		srl		a
03C5: C690    		add  	a,$90
03C7: 27      		daa
03C8: CE40    		adc  	a,$40
03CA: 27      		daa
03CB: FD7700  		ld		(iy+0),a
              	
              		; B
03CE: DD7E01  		ld		a,(ix+1)
03D1: E60F    		and		$0F		; now we only have B
03D3: C690    		add  	a,$90
03D5: 27      		daa
03D6: CE40    		adc  	a,$40
03D8: 27      		daa
03D9: FD7701  		ld		(iy+1),a
              	
              		; C
03DC: DD7E00  		ld		a,(ix)
03DF: E6F0    		and		$F0		; now we only have C
03E1: CB3F    		srl		a	
03E3: CB3F    		srl		a
03E5: CB3F    		srl 	a
03E7: CB3F    		srl 	a
03E9: C690    		add  	a,$90
03EB: 27      		daa
03EC: CE40    		adc  	a,$40
03EE: 27      		daa
03EF: FD7702  		ld		(iy+2),a
              	
              		; D
03F2: DD7E00  		ld		a,(ix)
03F5: E60F    		and		$0F		; now we only have D
03F7: C690    		add  	a,$90
03F9: 27      		daa
03FA: CE40    		adc  	a,$40
03FC: 27      		daa
03FD: FD7703  		ld		(iy+3),a
              	
0400: 3E00    		ld		a,0
0402: FD7704  		ld		(iy+4),a
              	
0405: C9      		ret
              	
              	;;;
0406:         	ConvertHex8ToString:
              		; Convert the value in HexToString_Source to ASCII characters.
              		; A
0406: FD211D81		ld		iy,HexToString_Dest
040A: DD211981		ld		ix,HexToString_Source
              	
040E: DD7E00  		ld		a,(ix)
0411: E6F0    		and		$F0		; now we only have A
0413: CB3F    		srl		a	
0415: CB3F    		srl		a
0417: CB3F    		srl 	a
0419: CB3F    		srl 	a
041B: C690    		add  	a,$90
041D: 27      		daa
041E: CE40    		adc  	a,$40
0420: 27      		daa
0421: FD7700  		ld		(iy+0),a
              	
              		; B
0424: DD7E00  		ld		a,(ix)
0427: E60F    		and		$0F		; now we only have B
0429: C690    		add  	a,$90
042B: 27      		daa
042C: CE40    		adc  	a,$40
042E: 27      		daa
042F: FD7701  		ld		(iy+1),a
              	
0432: 3E00    		ld		a,0
0434: FD7702  		ld		(iy+2),a
              	
0437: C9      		ret
              	
              	;;;;;;;;
0438:         	CmdDebugOutput:
0438: 112803  		ld		de,strDbgCmd
043B: 0E01    		ld		c,B_STROUT
              		DoBIOS
043D: E7      			rst	$20
043E: DD2A2981		ld		ix,(MON_Command)
0442: DD5D    		ld		e,ixl
0444: 0E00    		ld		c,B_CONOUT
              		DoBIOS
0446: E7      			rst	$20
0447: DD5C    		ld		e,ixh
0449: 0E00    		ld		c,B_CONOUT
              		DoBIOS
044B: E7      			rst	$20
044C: 110A03  		ld		de,strCRLF
044F: 0E01    		ld		c,B_STROUT
              		DoBIOS
0451: E7      			rst	$20
              	
0452: 113203  		ld		de,strDbgArg
0455: 0E01    		ld		c,B_STROUT
              		DoBIOS
0457: E7      			rst	$20
0458: 112B81  		ld		de,MON_Argument
045B: 0E01    		ld		c,B_STROUT
              		DoBIOS
045D: E7      			rst	$20
045E: 110A03  		ld		de,strCRLF
0461: 0E01    		ld		c,B_STROUT
              		DoBIOS
0463: E7      			rst	$20
              	
0464: C9      		ret
              	
              	;;;;;;;;;;;;;;;;;;
0465:         	GetArgument:
              	#local
              		; Copy B characters from buffer_Input+MON_ArgStartsAt into MON_Argument
0465: 210280  		ld		hl,buffer_Input
0468: 112B81  		ld		de,MON_Argument
              	
046B: 3A3581  		ld		a,(MON_ArgStartsAt)
046E: 4F      		ld		c,a
046F: 0600    		ld		b,0		; BC is now ArgStartsAt
0471: 09      		add		hl,bc
              		
              		; HL is now the beginning of the argument.
              		; DE is now the destination address.
0472:         	ArgumentCopyLoop:
0472: 7E      		ld		a,(hl)
0473: 12      		ld		(de),a
0474: 23      		inc		hl
0475: 13      		inc		de
0476: 10FA    		djnz	ArgumentCopyLoop
              	
0478: C9      		ret
              	#endlocal
              	
              	;;
              	;;
              	;;
              	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0479:         	ClearInputBuffer:
0479: 3E00    		ld		a,0
047B: 210280  		ld		hl,buffer_Input
047E:         	1$:
047E: 3600    		ld		(hl),0
0480: 23      		inc		hl
0481: 3C      		inc		a
0482: FEFF    		cp		$FF
0484: 20F8    		jr		nz,1$
0486: C9      		ret
              	
              	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
              	
0487:         	Monitor_DoMemoryLabel:
              		; Formatting: start address
0487: 2A2381  		ld		hl,(MemoryOutputCurAddr)
048A: 221981  		ld		(HexToString_Source),hl
048D: CDB003  		call	ConvertHex16ToString
0490: 111D81  		ld		de,HexToString_Dest
0493: 0E01    		ld		c,B_STROUT
              		DoBIOS
0495: E7      			rst	$20
0496: 1E3A    		ld		e,":"
0498: 0E00    		ld		c,B_CONOUT
              		DoBIOS
049A: E7      			rst	$20
049B: 1E20    		ld		e," "
049D: 0E00    		ld		c,B_CONOUT
              		DoBIOS
049F: E7      			rst	$20
04A0: C9      		ret
              	
04A1:         	Monitor_PrintBytes:
              		; Input:
              		; B  - how many bytes to dump
              		; IX - pointer to start of memory area to dump
04A1: C5      		push	bc
              	
04A2: DD7E00  		ld		a,(ix)						; A has a memory byte
04A5: 321981  		ld		(HexToString_Source),a		
04A8: DDE5    		push	ix
04AA: CD0604  		call	ConvertHex8ToString			; Convert it to ASCII
              	
              		; Print two characters of output and a space
04AD: 3A1D81  		ld		a,(HexToString_Dest)
04B0: 5F      		ld		e,a
04B1: 0E00    		ld		c,B_CONOUT
              		DoBIOS								
04B3: E7      			rst	$20
04B4: 3A1E81  		ld		a,(HexToString_Dest+1)
04B7: 5F      		ld		e,a
04B8: 0E00    		ld		c,B_CONOUT
              		DoBIOS
04BA: E7      			rst	$20
04BB: 1E20    		ld		e," "
04BD: 0E00    		ld		c,B_CONOUT
              		DoBIOS
04BF: E7      			rst	$20
              	
              		; Advance the memory source pointer. Continue until B == 0.
04C0: DDE1    		pop		ix
04C2: DD23    		inc		ix
              	
04C4: C1      		pop		bc
04C5: 10DA    		djnz	Monitor_PrintBytes
              	
04C7: C9      		ret
              	
04C8:         	Monitor_DoMemoryOutput:
              	#local
04C8: 2A2181  		ld		hl,(MemoryOutputStartAddr)
04CB: 222381  		ld		(MemoryOutputCurAddr),hl
              	
04CE: CD8704  		call	Monitor_DoMemoryLabel
              	
              		; Output 16 memory bytes
04D1: 2A2581  		ld		hl,(MemoryOutputEndAddr)
04D4: ED4B2181		ld		bc,(MemoryOutputStartAddr)
04D8: 37      		scf
04D9: 3F      		ccf		; Clear carry flag to get the proper subtraction result.
04DA: 23      		inc		hl	
04DB: ED42    		sbc		hl,bc
04DD: 222781  		ld		(MemoryOutputBytesLeft),hl
              	
04E0: DD2A2181		ld		ix,(MemoryOutputStartAddr)
04E4: 0610    		ld		b,16
04E6: CDA104  		call	Monitor_PrintBytes
              	
04E9:         	EndMemoryLine:
04E9: 110A03  		ld		de,strCRLF
04EC: 0E01    		ld		c,B_STROUT
              		DoBIOS
04EE: E7      			rst	$20
              	
04EF: 2A2781  		ld		hl,(MemoryOutputBytesLeft)
04F2: 37      		scf
04F3: 011000  		ld		bc,16
04F6: ED42    		sbc		hl,bc	; Subtract the 16 bytes we already read.
04F8: FA1A05  		jp		m,Done	; End if we're out of memory to write.
04FB: CA1A05  		jp		z,Done	; End if we're out of memory to write.
04FE: 222781  		ld		(MemoryOutputBytesLeft),hl
              	
0501: 011000  		ld		bc,16
0504: 2A2381  		ld		hl,(MemoryOutputCurAddr)
0507: 09      		add		hl,bc						; Advance start pointer
0508: 222381  		ld		(MemoryOutputCurAddr),hl	
050B: CD8704  		call	Monitor_DoMemoryLabel
              	
050E: 0610    		ld		b,16						; Another 16 bytes
0510: DD2A2381		ld		ix,(MemoryOutputCurAddr)
0514: CDA104  		call	Monitor_PrintBytes
0517: C3E904  		jp		EndMemoryLine
              	
051A:         	Done:
051A: C9      		ret
              	#endlocal
              	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
              	
8000:         	#data DATA,0x8000,0x8000	; Data section in RAM. Assume 32K of RAM on an RC2014.
              	
8000:         	buffer_base:
8000: 00      	buffer_len:				.db 0
8001: 00      	buffer_inputsize:		.db 0
8002: 00000000	buffer_Input:			.ds	255	; 255 bytes of input storage
8006: 00...   	buffer_Input:			.ds	255	; 255 bytes of input storage
              	
              	;;;
8101: 00000000	StringToHex_Source:		.ds 16
8105: 00...   	StringToHex_Source:		.ds 16
8111: 00000000	StringToHex_Dest:		.ds 8
8115: 00000000	StringToHex_Dest:		.ds 8
              	
8119: 00000000	HexToString_Source:		.ds	4
811D: 00000000	HexToString_Dest:		.ds 4
              	
              	;;;
8121: 0000    	MemoryOutputStartAddr:	.dw 0
8123: 0000    	MemoryOutputCurAddr:	.dw 0
8125: 0000    	MemoryOutputEndAddr:	.dw 0
8127: 0000    	MemoryOutputBytesLeft:	.dw 0
              	
              	;;;;;;;;;;;;;;;;;;;
              	; ROM monitor data stuff
8129: 0000    	MON_Command:		.dw		0
812B: 00000000	MON_Argument:		.ds		10
812F: 00...   	MON_Argument:		.ds		10
8135: 00      	MON_ArgStartsAt: 	.db		0
              	
              	#end


total time: 0.2936 sec.
no errors
